/**
@mainpage Linear Allocator Documentation

@section intro Introduction

This is a Data-Oriented Programming implementation of a simplified linear allocator with precise alignment control. The allocator follows strict DOP principles with public data members, struct methods, and no getters/setters.

@section overview Overview

This implementation provides a simple linear allocator with alignment specification following data-oriented programming principles. The allocator supports:

- Precise memory alignment for any data type
- Using `uint8_t*` instead of `char*` for pointer arithmetic
- Passing the allocator by reference to functions
- Memory reset operation
- Error handling via `std::expected` (C++23)

@section design Design Principles

The `LinearAllocator` adheres to data-oriented design:
- Public data members (no getters/setters)
- Methods defined inline within the struct declaration
- No private encapsulation
- Separation of data and behavior where appropriate
- Simplified memory management (user manages freeing)

@section usage Basic Usage

@subsection creation Creating an Allocator

```cpp
// Create a 1KB allocator
auto allocator_result = alloc::LinearAllocator::create(1024);
if (!allocator_result) {
    // Handle error
    return;
}

auto& allocator = allocator_result.value();
```

@subsection allocation Allocating Memory

```cpp
// Allocate memory for an integer
auto int_result = allocator.allocate<int>();
if (int_result) {
    int* value = int_result.value();
    *value = 42;
}

// Allocate an array with specific alignment
auto array_result = allocator.allocate<float>(10, 16); // 16-byte alignment
if (array_result) {
    float* array = array_result.value();
    // Use array...
}
```

@subsection func Passing to Functions

```cpp
std::expected<Point*, alloc::AllocError> create_points(alloc::LinearAllocator& alloc) {
    auto points_result = alloc.allocate<Point>(3);
    if (!points_result) {
        return std::unexpected(points_result.error());
    }

    Point* points = points_result.value();
    // Initialize points...
    return points;
}
```

@subsection reset Memory Management

```cpp
// Reset the allocator (keeps the memory but resets usage counter)
allocator.reset();

// Remember to manually free the memory when done
std::free(allocator.buffer);
```

@section errors Error Handling

The allocator uses `std::expected` for error handling:

```cpp
auto result = allocator.allocate<int>();
if (!result) {
    switch (result.error()) {
        case alloc::AllocError::OutOfMemory:
            // Handle out of memory
            break;
        case alloc::AllocError::InvalidAlignment:
            // Handle invalid alignment
            break;
    }
}
```

@section integration Integration with Other Projects

See the @ref library_usage page for detailed instructions on how to integrate this allocator into your own projects.
*/
